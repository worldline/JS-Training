<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
		<link rel="icon" type="image/x-icon" href="./assets/img/JavaScript-logo.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript Training</title>
	<link rel="stylesheet" href="./assets/css/global.css">
  </head>
  <body>
		<div class="reveal">
			<div class="menubar" id="menubar" style="display: none">
				<div class="dropdown">
					<input id="checkbox_toggle" type="checkbox">
					<label for="checkbox_toggle" data-i18n="chooselanguage">Language</label>
					<div class="langchooser">
						<label>
								<input type="radio" name="menulangradios" value="en" checked><span>English</span>
						</label>
						<label>
								<input type="radio" name="menulangradios" value="fr"><span>Français (work in progress)</span>
						</label>
					</div>
				</div>
			</div>
			<div class="slides">
				<section id="intro">
					<a href="./"><img src="./assets/img/JavaScript-logo.png" alt="logo" class="logo"></a>
					<h1 data-i18n="title">JavaScript Training</h1>
					<p>
						<a href="https://github.com/worldline/JS-Training" target="_blank">
							https://github.com/worldline/JS-Training
						</a>
					</p>
        </section>
				<section class="small-list">
					<ul>
						<li>
							This course is for developers who already have a beginner to intermediate level in JavaScript and who 
							wish to deepen their knowledge of this language to better understand more ambitious JavaScript projects.
						</li>
						<li>
							It is classified as advanced, which means that we will focus more on some technical aspects of the language 
							and on the study of some advanced programming patterns.
						</li>
						<li>
							The training focuses on the language and is agnostic of any framework or environment, meaning that you 
							will be able to apply these lessons to both front-end (Angular, Vue.js, Ember...) and back-end (Node.js).
						</li>
						<li>
							It is the ideal opportunity to review and consolidate the basics for all those who have learned 
							JavaScript "on the job", or to prepare or complement a training on a modern web framework.
						</li>
					</ul>
				</section>
				<section class="agenda">
					<h2>Agenda</h2>
					<div class="flex-slide">
						<div style="flex-basis: 100%;">
							<p class="chapter-title">Introduction</p>
							<ul>
								<li>ECMAScript, TC39 and versions of JavaScript</li>
							</ul>
	
							<p class="chapter-title">A reintroduction to JavaScript</p>
							<ul>
								<li>Primitives and Objects</li>
								<li>Property descriptors</li>
								<li>Scopes and Closures</li>
								<li>Functions and contexts</li>
								<li>Implicit casts</li>
							</ul>
						</div>

						<div style="flex-basis: 100%;">
							<p class="chapter-title">Modern JS: ES2015+</p>
							<ul>
								<li>Arrow functions</li>
								<li>Default parameters</li>
								<li>Spread / Rest</li>
								<li>Destructuring</li>
								<li>Template literals</li>
								<li>Map and Sets</li>
								<li>Modules</li>
							</ul>
	
							<p class="chapter-title">Managing asynchronicity</p>
							<ul>
								<li>Asynchronicity, what is it?</li>
								<li>Callbacks and Pub/Sub</li>
								<li>Promises</li>
								<li>async / await</li>
								<li>Observables</li>
							</ul>
						</div>

						<div style="flex-basis: 100%;">
							<p class="chapter-title">Object oriented</p>
							<ul>
								<li>Prototypes and delegation</li>
								<li>class / super / extends</li>
								<li>Composition of objects</li>
								<li>Symbols, iterables and generators</li>
								<li>Proxies</li>
							</ul>
	
							<p class="chapter-title">Functional programming</p>
							<ul>
								<li>Recursivity</li>
								<li>Chainable APIs</li>
								<li>Function Composition</li>
								<li>Currying</li>
							</ul>

							<p class="chapter-title">Transpilers</p>
							<ul>
								<li>Babel</li>
								<li>TypeScript, JSX</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<section>
						<h2>Cheat Sheets</h2>
						<p>It can be useful</p>
					</section>
					<section>
						<h3>String Methods</h3>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim data-line-numbers>
							"str".charAt(1) === "str"[1] === "t"
							"a".concat("b") === "a" + "b" === "ab"
							"str".startsWith("s") === true
							"str".endsWith("r") === true
							"str".includes("st") === true
							"toto".indexOf("t") === 0
							"toto".lastIndexOf("t") === 2
							"str".search(/t/) === 1
							"str1".match(/r(\d)/) => ["r1", "1"]
							"Hi Bob".replace(/Hi (\w+)/, "Hello $1") => "Hello Bob"
							"string".slice(0,3) === "str"
							"1,2,3".split(",") => ["1","2","3"]
							"STR".toLowerCase() === "str"
							"str".toUpperCase() === "STR"
							"  str  ".trim() == "str"
						</code></pre>
					</section>
					<section>
						<h3>Array Methods</h3>
						<pre style="font-size: 50%"><code class="javascript hljs" data-trim data-line-numbers>
							[1,2].concat([3,4], 5, 6) // [1,2,3,4,5,6]
							[1,2,3].fill(4) // [4,4,4]
							[1,2,3].includes(2) // true
							[1,2,3].indexOf(2) // 1
							[1,2,3].join("-") // "1-2-3"
							[1,2,3,4].slice(1,3) // [2,3]
							
							[1,2,3,4].every((value, index, arr) => n > 2) // false
							[1,2,3,4].some((value, index, arr) => n > 2) // true
							[1,2,3,4].find((value, index, arr) => n > 2) // 3
							[1,2,3,4].findIndex((value, index, arr) => n > 2) // 2
							[1,2,3,4].filter((value, index, arr) => n > 2) // [3,4]
							[1,2,3,4].forEach((value, index, arr) => { ... })
							[1,2,3,4].map((val, index, arr) => val * 2) // [2,4,6,8]
							[1,2,3,4].reduce((accu, n) => accu + n, "test") // "test1234"
							[1,2,3,4].reduceRight((accu, n) => accu + n, "test") // "test4321"
							
							// /!\ Mutative methods, original array is modified!
							let arr = [3,2,1]
							arr.push(4,5) // returns new array.length (5), a = [3,2,1,4,5]
							arr.pop() // returns last item (5), a = [3,2,1,4]
							arr.unshift(6,5) // returns new array.length (6) ; a = [6,5,3,1,2,4]
							arr.shift() // returns first item (6) ; a = [5,3,1,2,4]
							arr.splice(1,2,7,8) // at index 1, remove 2 items, insert (7,8) ; [5,7,8,2,4]
							arr.sort((a,b) => a-b) // [2,4,5,7,8]
							arr.reverse() // [8,7,5,4,2]
						</code></pre>
					</section>
					<section>
						<h3>Map</h3>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim data-line-numbers>
							let map = new Map([ ['key1', 'val1'], ['key2', 'val2'] ])
							let key = {}, value = {} // any type
							
							map.set(key, value)
							map.get(key) === value
							map.has(key) === true
							map.delete(key);
							map.size === 2
							
							let keys = [...map.keys()]
							let values = [...map.values()]
							let fusionMap = new Map([...map1, ...map2])
							
							for(let [key, val] of map){ }
							map.forEach((val, key, map) => {})
						</code></pre>
					</section>
					<section>
						<h3>Set</h3>
						<pre><code class="javascript hljs" data-trim data-line-numbers>
							let mySet = new Set([ 1,2,3,4 ])
								▸ Set(4) {1, 2, 3, 4}

							mySet.add("any type")
							map.has(3) === true
							map.delete(3);
							map.size === 4;
							map.clear(); // remove all
							 
							for(let item of mySet){}
							mySet.forEach(item => {})
							let items = [...mySet];
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Introduction</h2>
						<p>
							Who manages JavaScript? How is the language evolving? <br />
							ECMAScript, TC39 and JavaScript versions
						</p>
					</section>
					<section>
						<h3 class="flex-center">ECMAScript <img height="50px" src="assets/img/ecma.jpg"></h3>
						<ul>
							<li>
								<b>ECMA International</b> is an organisation that creates standards for technologies
							</li>
							<li>
								<b>ECMAScript</b> is the name of the specification referenced ECMA-262 and describing a general purpose scripting language
							</li>
							<li>
								<b>TC39</b> is the name of the technical committee that decides on developments in the ECMAScript specification. 
								It is composed of delegates from <b>major companies</b> (including all browser providers) and <b>invited experts.</b>
							</li>
							<li>
								<b>JavaScript</b> is a versatile scripting language and the most popular implementation of ECMAScript<br>
								<em>(another popular implementation: ActionScript)</em>
							</li>
						</ul>
					</section>
					<section style="text-align: left;">
						<h3>JavaScript Evolutions</h3>
						<p>
							TC39 is considering proposals for ECMAScript developments. Each proposal goes through 5 stages:
						</p>
						<ul>
							<li>0:
								<b>Strawman -</b> suggestion of a need, call for ideas
							</li>
							<li>1:
								<b>Proposal -</b> draft solution, first polyfills/demos
							</li>
							<li>2:
								<b>Draft -</b> precisely describes the syntax/API
							</li>
							<li>3:
								<b>Candidate -</b> signed by the whole committee, call for implementations
							</li>
							<li>4:
								<b>Finished -</b> ready to be included in the next version of ES
							</li>
						</ul>
						<div style="text-align: center;">
							<p>TC39 proposals and meetings are public: <a href="https://github.com/tc39">github.com/tc39</a></p>
							<aside class="note warning">
								Any proposal before stage 4 can be dropped completely. <br />
								However, from stage 3 onwards, the level of confidence is quite high.	
							</aside>
						</div>
					</section>
					<section>
						<h3>Versions of ECMAScript</h3>
						<img src="./assets/img/ecmascript-versions.png" height="150px">
						<p>
							A long delay between initial draft and release implies many browser-specific implementations.
						</p>
						<p>
							TC39 has decided to move to an annual release schedule from ES6, renamed <b>ES2015</b>
						</p>
						<p>
							Since 2015, a new version of the ECMAScript specification is released every year: ES2016, ES2017...
						</p>
					</section>
					<section>
						<h3>ECMAScript browser implementation</h3>
						<p>
							As a result of the new annual rhythm:<br />
							<small>an excellent, comprehensive and consistent support across all modern browsers</small>
						</p>
						<div class="flex-center">
							<p>So-called "<span class="green">evergreen</span>" browsers</p>
							<img height="450px" src="./assets/img/evergreen.png">
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>A reintroduction to JS</h2>
						<p>Exercises 1 to 6</p>
					</section>
					<section style="text-align: left;">
						<h3>Exercises</h3>
						<p>
							Slides and exercises available on Github:
							<a href="https://github.com/worldline/JS-Training">https://github.com/worldline/JS-Training</a>
						</p>
						<p>
							Do the exercises from your browser at this address:
							<a href="https://codesandbox.io/s/github/SDCOAdvocates/JS-Training">https://codesandbox.io/s/github/SDCOAdvocates/JS-Training</a>
						</p>
						<img src="./assets/img/Image1.png">
						<p>
							Fork to create your personal version of the working repo. 
							You can publish it on your personal Github account if you have one.
						</p>
						<div class="flex-center">
							<img height="142px" src="./assets/img/Image2.png">
							<img height="142px" src="./assets/img/Image3.png">
							<img height="142px" src="./assets/img/Image4.png">
						</div>
						<p>For each exercise, correct the source to validate the associated test</p>
					</section>
					<section>
						<h3>Types and Primitives</h3>
						<span class="ref">Exercise 1</span>
						<p>JavaScript defines 7 data types:</p>
						<img height="250px" src="./assets/img/Image5.png">
						<p>The <b class="monospace">typeof</b> operator returns the type of an object, but be careful:</p>
						<pre><code class="javascript hljs" data-trim>
							typeof null === "object" // bug of the 1st version of ES
							typeof function(){} === "function"
						</code></pre>
					</section>
					<section>
						<h3>null or undefined</h3>
						<ul>
							<li><b class="monospace">undefined</b> : the variable is declared but not assigned</li>
							<li><b class="monospace">null</b> : the variable has been assigned to the null reference</li>
						</ul>
						<p>
							<b class="monospace">null</b> represents the intentional absence of value and often comes from an assignment by the developer
						</p>
						<aside class="note warning">
							Don't assign variables to undefined. Use the delete operator instead:<br>
							<img height="70px" src="./assets/img/Image6.png">
						</aside>
					</section>
					<section style="text-align: left;">
						<h3>Objects</h3>
						<p>Functions, <b class="monospace">arrays</b> and derivatives are all of type <b class="monospace">object</b>. Unlike primitives, objects:</p>
						<ul>
							<li>are compared by reference</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							"test" === "test"
							▸ true
								
							{ item: "test" } === { item: "test" }
							▸ true
						</code></pre>
						<ul>
							<li>have a list of properties that are key-value pairs: key (String, Symbol) ⇔ value (any)</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							"item" in { item: "test" }
							▸ true
							
							Symbol.iterator in [1,2,3]
							▸ true
						</code></pre>
					</section>
					<section>
						<h3 class="flex-center">Objects: properties listing</h3>
						<span class="ref">Exercise 2</span>
						<pre style="font-size: 90%"><code class="javascript hljs" data-trim>
							let obj = { a: 1, b: 2 }

							"a" in obj
							▸ true

							for(let key in obj) console.log(key, obj[key])
							▸ a 1
							▸ b 2

							Object.keys(obj)
								▸ ["a", "b"]
							Object.values(obj)
								▸ [1, 2]
							Object.entries(obj)
								▸ [ ["a", 1], ["b", 2] ]
						</code></pre>
					</section>
					<section>
						<h3>Objects: properties assignment</h3>
						<span class="ref">Exercise 3</span>
						<pre><code class="javascript hljs" data-trim>
							let obj = { key: "value" }
							obj.a = 1;
							obj["b"] = 2;
							Object.assign(obj, { c: 3, d: 4}, {d: 5});
								▸ {key: "value", a: 1, b: 2, c: 3, d: 5}

							Object.fromEntries([ ['a', 1], ['b', 1]]);
								▸ {a: 1, b: 2}
						</code></pre>
						<aside  class="note info">
							<b class="monospace">Object.assign</b> is very useful for assigning default values 
							or assigning a set of properties in a single statement
						</aside>
					</section>
					<section style="text-align: left;">
						<h3>Property descriptors</h3>
						<p>Each property contains in addition to its value, a list of intrinsic parameters called <b>descriptors</b>:</p>
						<ul>
							<li><b class="monospace">value:</b> <em>the value of the property</em></li>
							<li><b class="monospace">enumerable: true</b> <em>if the property is returned by Object.keys or for..in</em></li>
							<li><b class="monospace">writable: true</b> <em>if the value of the property can be modified</em></li>
							<li><b class="monospace">configurable: true</b>: <em>if the descriptor can be modified</em></li>
							<li><b class="monospace">get</b>: <em>optional function to use as getter</em></li>
							<li><b class="monospace">set</b>: <em>optional function to use as mutator (setter)</em></li>
						</ul>
						<p>A default assignment is enumerable, modifiable and configurable, without specific accessors or mutators</p>
					</section>
					<section>
						<h3>Define the descriptors</h3>
						<span class="ref">Exercise 4</span>
						<p>The method <b class="monospace">Object.defineProperty()</b> allows you to assign a property by specifying its descriptors</p>
						<div class="flex-center">
							<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
								const obj = {}

								Object.defineProperty(obj, 'a', {
									value: 1,
									enumerable: true,
									writable: false
								});

								Object.defineProperty(obj, {
									b: { enumerable: true, value: 2 },
									c: { get: function(){ return 3 } },
								});
									
								▸ {a: 1, b: 2}			
							</code></pre>
							<img height="325px" src="./assets/img/Image7.png">
						</div>
					</section>
					<section>
						<h3>Getters / Setters</h3>
						<p>Literal declaration for get / set descriptors:</p>
						<pre><code class="javascript hljs" data-trim data-line-numbers>
							const user = {
								name: "Smith",
								first: "John",

								get fullName(){
									return this.first + " " + this.name.toUpperCase()
								},

								set fullName(value){
									this.first = value.split(" ")[0];
									this.name = value.split(" ")[1];
								}
							}
						</code></pre>
					</section>
					<section>
						<h3>Own and delegated properties</h3>
						<p>
							The properties assigned to an object are called the <b>own properties</b> of the object. 
							But there are other types of properties, the <b>delegated properties</b>.
						</p>
						<img height="150" src="./assets/img/Image8.png">
						<p>These delegated properties are in fact the properties of the object's prototype (see Object Oriented section)</p>
						<pre><code class="javascript hljs" data-trim>
							obj.toString === Object.prototype.toString
							▸ true
						</code></pre>
					</section>
					<section>
						<h3>Scopes</h3>
						<p><b>Scope</b> = perimeter from which variables can be accessed.</p>
						<p>At the highest level, we are in the global scope, accessible everywhere.</p>
						<img height="300" src="./assets/img/Image9.png">
						<p>
							Accessible from global scope<span class="green">(1)</span> : <span class="monospace">foo</span><br />
							Accessible from function foo scope <span class="red">(2)</span> : <span class="monospace">foo, a, b, bar</span><br />
							Accessible from function bar scope <span class="blue">(3)</span> : <span class="monospace">foo, a, b, bar, c</span><br />
						</p>
					</section>
					<section>
						<h3>Block scopes</h3>
						<p>In addition to function scopes, some instructions create so-called <b>block scopes</b></p>
						<p>These are known as <b>block instructions:</b></p>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>
								if(){ ... }
								for(){ ... }
								while(){ ... }
							</code></pre>
							<img height="150" src="./assets/img/Image10.png">
						</div>
						<p>
							A block scope can also be declared with <span class="monospace">{ ... }</span> <br />
							<em>(not to be confused with a literal object declaration)</em>
						</p>
					</section>
					<section>
						<h3>var, let or const?</h3>
						<ul>
							<li><b class="monospace">let</b> and <b class="monospace">const</b> appeared with ES2015</li>
							<li>they bind variables to <b>block scope</b> and not function scope like <code>var</code>, which is much more intuitive</li>
							<li><b class="monospace">var</b> is no longer used since</li>
						</ul>
						<div class="flex-slide">
							<img height="250" src="./assets/img/Image11.png">
							<table>
								<thead><tr><th></th><th>Scope</th><th>Re-assignable</th></tr></thead>
								<tbody>
									<tr><td class="monospace">var</td><td>function</td><td>yes</td></tr>
									<tr><td class="monospace">let</td><td>block</td><td>yes</td></tr>
									<tr><td class="monospace">const</td><td>block</td><td>no</td></tr>
								</tbody>
							</table>
						</div>
						<aside class="note info"><span style="text-decoration: underline">Recommended:</span> Use <code>const</code>, or <code>let</code> if you need to reassign</aside>
					</section>
					<section>
						<h3>Closures</h3>
						<p>Scope of a function = local scope + parent scope = local variables + non-local variables</p>
						<p>
							A function using <b>non-local variables</b> (defined in a parent scope) creates what is called a <b>closure</b>. 
							A closure must remember its parent scope in order to execute correctly.
						</p>
						<div class="cols-2">
							<div class="note info" style="font-size: 100%; font-style: italic">
								<p><b class="monospace">add5</b> retains its parent scope with <code>x=5</code></p>
								<p>This link prevents the garbage collector from dereferencing the local variable x at the end of the <b class="monospace">add</b> function</p>
								<p><b class="monospace">add5</b> creates a <b>closure</b></p>
							</div>
							<pre><code class="javascript hljs" data-trim>
								function add(x) {
									return function(y) {
										return x + y;
									}
								}

								var add5 = add(5);
								add5(8)
								▸ 13
							</code></pre>
						</div>
						<aside class="note warning">
							Unintentional closures are the most common source of <b>memory leaks</b> problems in web applications.
						</aside>
					</section>
					<section>
						<h3>Using closures to make "private" variables</h3>
						<pre><code lass="javascript hljs" data-trim>
							function getCounter() {
								let value = 0;
								return {
									getValue(){ return value },
									increment() { value += 1 }
								}
							}
						</code></pre>
						<p>Outside the scope of the <b class="monospace">getCounter</b> function, the value variable will never be accessible.</p>
						<p>Only the <b class="monospace">getValue</b> and <b class="monospace">increment</b> closures allow access</p>
					</section>
					<section>
						<h3>Using closures</h3>
						<span class="ref">Exercise 5</span>
						<pre><code class="javascript hljs" data-trim>
							for (var i = 1; i&lt;=3; i++) {
								setTimeOut( function timer(){
									console.log( i );
								}, i*1000 );
							}

							▸ 4
							▸ 4
							▸ 4
						</code></pre>
						<aside class="note">
							Note that closures retain a reference to the parent scope,<br> 
							and therefore access non-local variables by <b>reference</b>, not by value. <br>
							<br>
							The value of the non-local variables can therefore vary depending on when the function is called.
						</aside>
					</section>
					<section class="left">
						<h3>Functions and execution context</h3>
						<p>
							Functions have some kind of hidden argument called <b>context</b> and assigned to the keyword <b class="monospace">this</b> inside the function body.</p>
							<p>When a function is called as a property of an object, we call it a <b>method</b> and that parent object is assigned as execution context of the method:
						</p>
						<pre><code class="javascript hljs" data-trim>
							const obj = {
								whoisthis(){ return this }
							}

							obj.whoisthis() === obj
							▸ true
						</code></pre>
						<p>
							When a function is called by direct reference, it has no context, which means the <code>this</code> variable will be looked up in parent scope.</p>
						<p>At the <b>root scope</b>, the context is defined as the <b>global context</b> (<code>Window</code> on browser)</p>
						<img height="80" src="./assets/img/Image12.png">
					</section>
					<section>
						<h3>Functions and execution context</h3>
						<p>
							The execution context can be changed with the methods 
							<span class="monospace">call</span>, 
							<span class="monospace">apply</span> and <span class="monospace">bind</span>
						</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							function greet(a, b) {
								return `Hi I'm ${this.name} ! ${a} + ${b} equals ${a+b} !`
							}

							let alice = { name: "Alice" },
									bob = { name: "Bob" };

							greet.call(alice, 1, 2)
							▸ "Hi I'm Alice ! 1 + 2 equals 3 !"

							greet.apply(bob, [2, 3])
							▸ "Hi I'm Bob ! 2 + 3 equals 5 !"

							let greetBob = greet.bind(bob, 1, 5)
							greetBob()
							▸ "Hi I'm Bob ! 1 + 5 equals 6 !"
						</code></pre>
						<p>These methods are available on all functions.</p>
					</section>
					<section>
						<h3>Primitives wrappers</h3>
						<p>
							<span class="monospace">String()</span>, <span class="monospace">Number()</span>, 
							<span class="monospace">Boolean()</span> are the object equivalent constructors of the corresponding 
							primitives, also called <b>primitive wrappers</b>
						</p>
						<p>The switch between object and primitive is automatic:</p>
						<div class="flex-center">
							<div style="flex-basis: 100%;">
								<p class="center">Primitive -> Object</p>
								<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
									let str = "abc";

									str.length; // 3
									str.toUpperCase(); // "ABC"
								</code></pre>
							</div>
							<div style="flex-basis: 100%;">
								<p class="center">Object -> Primitive</p>
								<pre style="font-size: 65%"><code class="javascript hljs" data-trim>
									let Str = new String( "abc" ),
											str = Str.valueOf() // ou "" + Str
									let N = new Number( 42 ),
											n = N.valueOf() // +N

									console.log(Str, typeof Str) // "abc", "object"
									console.log(str, typeof str) // "abc", "string"
									console.log(N, typeof N) // 42, "object"
									console.log(n, typeof n) // 42, "number"
								</code></pre>
							</div>
						</div>
						<aside class="note">Generally, primitive wrappers constructors are not called explicitly</aside>
					</section>
					<section>
						<h3>Type conversions (cast)</h3>
						<p>There are 3 types of automatic type conversions in JS:</p>
						<table class="slide-array" style="width: 80%">
							<thead><tr><th></th><th>Explicit cast</th><th>Implicit cast</th><th>Cast operators</th></tr></thead>
							<tbody>
								<tr>
									<td>ToString</td>
									<td><pre><code class="javascript hljs" data-trim>
										String(42)
										▸ "42"
									</code></pre></td>
									<td><pre><code class="javascript hljs" data-trim>
										12 + "34"
										▸ "1234"
									</code></pre></td>
									<td><pre><code data-trim>'' +</code></pre></td>
								</tr>
								<tr>
									<td>ToNumber</td>
									<td><pre><code class="javascript hljs" data-trim>
										Number("42")
										▸ 42
									</code></pre></td>
									<td><pre><code class="javascript hljs" data-trim>
										+"42"
										▸ 42
									</code></pre></td>
									<td>
										<pre><code class="javascript hljs" data-trim>- + * / %</code></pre>
										<pre><code class="javascript hljs" data-trim>> &lt; &lt;= >=</code></pre>
										<pre><code class="javascript hljs" data-trim>| & ^ ~</code></pre>
									</td>
								</tr>
								<tr>
									<td>ToBoolean</td>
									<td><pre><code class="javascript hljs" data-trim>
										Boolean(1)
										▸ true
									</code></pre></td>
									<td><pre><code class="javascript hljs" data-trim>
										!!1
										▸ true
									</code></pre></td>
									<td>
										<pre><code class="javascript hljs" data-trim>|| && !</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<aside class="note info"><span style="font-weight: bold; text-decoration: underline">Recommended</span>: cast explicitly and as soon as possible</aside>
					</section>
					<section>
						<h3>== or === ?</h3>
						<p>
							== weak equality (with conversion) <br />
							=== strict equality (without conversion)
						</p>
						<img height="250" src="./assets/img/Image13.png">
						<div class="note info">
							The rules for conversion with weak equality are <a href="https://eqeq.js.org/" target="_blank">very complex</a>. <br /> 
							It's recommended to use strict equality, which is more predictable.
						</div>
					</section>
					<section class="quizz">
						<h3>Implicit casts</h3>
						<span class="ref">Quiz</span>
						<div class="flex-slide">
							<div style="flex-basis: 100%;">
								<p><pre class="fragment fade"><code>"0"-0</code></pre><pre class="fragment fade"><code>▸ 0</code></pre></p>
								<p><pre class="fragment fade"><code>"0"+0</code></pre><pre class="fragment fade"><code>▸ "00"</code></pre></p>
								<p><pre class="fragment fade"><code>+"1"+2</code></pre><pre class="fragment fade"><code>▸ 3</code></pre></p>
								<p><pre class="fragment fade"><code>+1+"2"</code></pre><pre class="fragment fade"><code>▸ "12"</code></pre></p>
							</div>

							<div style="flex-basis: 100%;">
								<p><pre class="fragment fade"><code>!"0"</code></pre><pre class="fragment fade"><code>▸ false</code></pre></p>
								<p><pre class="fragment fade"><code>!+"0"</code></pre><pre class="fragment fade"><code>▸ true</code></pre></p>
								<p><pre class="fragment fade"><code>+!"0"</code></pre><pre class="fragment fade"><code>▸ 0</code></pre></p>
								<p><pre class="fragment fade"><code>+"test"</code></pre><pre class="fragment fade"><code>▸ NaN</code></pre></p>
							</div>

							<div style="flex-basis: 100%;">
								<p><pre class="fragment fade"><code>+[1]</code></pre><pre class="fragment fade"><code>▸ 1</code></pre></p>
								<p><pre class="fragment fade"><code>+[1,2]</code></pre><pre class="fragment fade"><code>▸ NaN</code></pre></p>
								<p><pre class="fragment fade"><code>![]</code></pre><pre class="fragment fade"><code>▸ false</code></pre></p>
								<p><pre class="fragment fade"><code>!+[]"</code></pre><pre class="fragment fade"><code>▸ true</code></pre></p>
							</div>
						</div>
					</section>
					<section>
						<h3>Logical operators</h3>
						<p>Operands are converted to Booleans to evaluate the operator, but the original values are returned</p>
						<pre><code class="javascript hljs" data-trim>
							let a = 42,
							b = "abc",
							c = null;
							
							a || b; 	// 42
							a && b;		// "abc"
							
							c || b;		// "abc"
							c && b;		// null
						</code></pre>
						<aside class="monospace note info">
							a || b ⇔ a ? a : b <br>
							a && b ⇔ a ? b : a
						</aside>
						<p>
							If the implicit Boolean cast of a value is <span class="monospace">true</span>, 
							the value is said to be <em>truthy</em>, otherwise <em>falsey</em>
						</p>
					</section>
					<section>
						<h3>Logical operators</h3>
						<span class="ref">Exercise 6</span>
						<p>
							The operators <span class="monospace">||</span> and <span class="monospace">&&</span>, 
							the ternary conditions <span class="monospace">?:</span> and <br>
							<span class="monospace">if else</span> statements execute only one operand here:
						</p>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>if(0) log('A'); else log('B');</code></pre>
							<p class="fragment fade">B</p>
						</div>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>undefined ? log('C') : log('D');</code></pre>
							<p class="fragment fade">D</p>
						</div>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>true && log('E'); false && log('F');</code></pre>
							<p class="fragment fade">E</p>
						</div>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>true log('G'); false || log('H');</code></pre>
							<p class="fragment fade">H</p>
						</div>
						<p>
							The <span class="monospace">&&</span> operator has priority over <span class="monospace">||</span> 
							which has priority over <span class="monospace">?:</span>
						</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Upgrade to modern JS: ES2015+</h1>
						<p>Exercises 7 to 11</p>
					</section>
					<section>
						<h3>Syntactic sugar: key and value</h3>
						<pre><code class="javascript hljs" data-trim>
							let foo = "foo", bar = "bar"

							const obj = { foo, bar } // equivalent to { foo: foo, bar: bar }

							obj
							▸ {foo: "foo", bar: "bar"}
						</code></pre>
					</section>
					<section>
						<h3>Syntactic sugar: calculated keys</h3>
						<pre><code class="javascript hljs" data-trim>
							let foo = "foo", bar = "bar"

							const obj = {
								[foo]: [bar],
								[foo+bar]: foo+bar
							} 
							
							/* equivalent to
							obj[foo] = [bar]
							obj[foo+bar] = foo + bar
							*/
						</code></pre>
						<pre><code class="javascript hljs" data-trim>
							obj
							▾ {foo: Array(1), foobar: "foobar"}
								▸ foo: ["bar"]
									foobar: "foobar"
						</code></pre>
					</section>
					<section class="left">
						<h3>Arrow functions</h3>
						<span class="ref">Exercise 7</span>
						<pre><code class="javascript hljs" data-trim>
							const f1 = () => {},
										f2 = x => x*2,
										f3 = (a,b,c) => { return a+b+c }
						</code></pre>
						<p>Functions declared with this shortened syntax have specific features:</p>
						<ul>
							<li>No execution context <br>
							<span class="grey">(the value of <span class="monospace">this</span> is looked up in the parent scope)</span></li>
							<li>Cannot be invoked as builders</li>
						</ul>
						<p>Short and effective, they encourage a functional, no-frills style <em>(no closure)</em>.</p>
						<div class="note info">Arrow functions are recommended for all non-method functions</div>
					</section>
					<section>
						<h3>Default parameters</h3>
						<p>
							Assigns a default value if argument === <span class="monospace">undefined</span>
						</p>
						<pre><code class="javascript hljs" data-trim>
							function f(a, b=1, c=2) { return a + b + c }

							f(1, 2, 3)
							▸ 6
							f(1, null, null)
							▸ 1
							f(1, undefined, undefined)
							▸ 4
							f(1)
							▸ 4
						</code></pre>
						<p>Also works with the arrow functions:</p>
						<pre><code class="javascript hljs" data-trim>const doSomething = (params = {}) => {}</code></pre>
					</section>
					<section>
						<h3>Operators Spread / Rest</h3>
						<p>Spread: converts an iterable object into an argument list</p>
						<pre><code class="javascript hljs" data-trim>
							const sum = (a,b,c) => a+b+c;

							sum(...[1,2,3])
							▸ 6

							sum(1, ...[2,3])
							▸ 6

							[1, ...[2,3], 4]
							▸ (4) [1,2,3,4]
						</code></pre>

						<pre><code class="javascript hljs" data-trim>const cloneArray = arr => [...arr]</code></pre>
					</section>
					<section>
						<h3>Operators Spread / Rest</h3>
						<p>Rest : converts a list of arguments into an Array</p>
						<pre><code class="javascript hljs" data-trim>
							const sum = (...args) => args.reduce((a,b) => a+b, 0);

							sum(1,2,3,4)
							▸ 10

							function addToList(list, ...args) { // rest
								list.push(...args) // spread
							}
						</code></pre>
					</section>
					<section class="left">
						<h3>Operators Spread / Rest</h3>
						<span class="ref">Exercise 8</span>
						<p>Object properties (ES2018)</p>
						<p>Only works with enumerable properties</p>
						<ul>
							<li>Rest properties:</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
							x; // 1
							y; // 2
							z; // { a: 3, b: 4 }
						</code></pre>
						<ul>
							<li>Spread properties:</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							let n = { x, y, ...z };
							n; // { x: 1, y: 2, a: 3, b: 4} 
						</code></pre>
					</section>
					<section>
						<h3>Destructuring</h3>
						<p>Assigns variables according to an object / Array structure</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							const userData = { first: "Joe", name: "Dalton", age: 27 };
							
							const { first, age, name: userName } = userData;
							// first = "Joe", age = 27, userName = "Dalton"

							const myObject = {
								foo: {
									bar: 42
								}
							}
							const { foo: { bar: magicNumber } } == myObject
							// magicNumber = 42

							const [first, second, fourth] = [1,2,3,4];
							// first = 1, second = 2, fourth = 4
						</code></pre>
					</section>
					<section class="left">
						<h3>Destructuring</h3>
						<span class="ref">Exercise 9</span>
						<p>Also works with function parameters:</p>
						<pre><code class="javascript hljs" data-trim>
							function doSomething({ config, options: { verbose } }){
								if(verbose) console.log("blabla");
								doSomethingElse(config);
							}

							doSomething({
								config: { ... },
								options: { verbose: true }
							})
						</code></pre>
					</section>
					<section>
						<h3>Default parameters</h3>
						<ul>
							<li>Can be expressions using other arguments or variables in the scope.</li>
							<li>If the default value is an expression, it will only be executed if necessary</li>
						</ul>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							function doSomething(data, config = retrieveDefaultConfig(data)) {
								
							}

							const required = name => throw new Error(`Missing required paramter ${name}`)

							const findUsersByRole = ({
								role = required('role'),
								maxResults = 100
							}) => { }
						</code></pre>
					</section>
					<section class="left">
						<h3>Parameterized object argument pattern</h3>
						<p>Instead of passing several arguments to functions, a popular pattern is to pass an object as single argument with the different parameters as properties:</p>
						<pre><code class="javascript hljs" data-trim>
							const searchProducts = ({
								minPrice = 0,
								maxPrice = 1000,
								inStock = true
							}) => {
								(...)
								return { results, size, lowestPrice }
							}

							const { results, size } = searchProducts({ maxPrice: 500 });
						</code></pre>

						<p>Receiving and returning a single object is very useful:</p>
						<ul class="narrow">
							<li>no need to remember the order of the arguments</li>
							<li>each parameter can be optional</li>
							<li>we limit the quantity of variables to be passed from one point to another</li>
							<li>allows you to return several variables</li>
						</ul>
					</section>
					<section>
						<h3>Template strings</h3>
						<p>Template Strings are a new literal String declaration introduced in ES2015.</p>
						<p>It uses the backtick <code>` `</code> character.</p>
						
						<div class="flex-center">
							<div>
								<p>This new literal declaration allows:</p>
								<ul>
									<li>interpolation of variables and expressions</li>
									<li>line breaks</li>
								</ul>
							</div>
							
							<img height="100" src="./assets/img/Image15.png">
						</div>
						<div class="note info"><span style="text-decoration: underline; font-weight: bold">Recommended</span>: use template strings for all non-trivial strings</div>
					</section>
					<section>
						<h3>Tagged Template strings</h3>
						<span class="ref">Exercise 10</span>
						<p>If a function reference precedes a template string literal, that function is invoked with the static and dynamic parts of the following string:</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							function insertInUpperCase(string, ...vars) {
								console.log({ strings, vars });

								return strings.reduce(
									(out, str, i) => `${out}${str}={vars[i] || "").toUpperCase()}`
								)
							}
						</code></pre>
						<img height="200" src="./assets/img/Image16.png">
						<img height="200" src="./assets/img/Image17.png">
					</section>
					<section class="left">
						<h3>Map & Set</h3>
						<span class="ref">Exercise 11</span>
						<ul>
							<li><code>Map</code>: collection of keys/values like objects, but the keys can be of any type</li>
							<li><code>Set</code>: collection of values without keys, not ordered but with guarantee of uniqueness</li>
						</ul>
						<div class="cols-2">
							<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
								s = new Set([1,2,3,2,4])
								▸ Set(4) {1,2,3,4}

								s.add(5);
								s.delete(3);
								▸ Set(4) {1,2,4,5}

								s.has(4)
								▸ true
							</code></pre>
							<pre style="font-size: 70%"><code class="javascript hljs" data-trim>
								m = new Map([
									["key", "value"], [ s, s.size ]
								])
								▸ Map(2) { "key" => "value", Set(4) => 4}
								
								m.get(s)
								▸ 4
								
								m.set([1,2,3], [4,5,6])
								m.delete("key")
								
								▸ Map(2) {Set(4) => 4, Array(3) => Array(3)}
							</code></pre>
						</div>
					</section>
					<section class="left">
						<h3>Modules (a.k.a. ES Modules or ESM in short)</h3>
						<p>The long awaited standard solution for managing modular code (divided into several separate files)</p>
						<p><b><u>Replaces and supersedes:</u></b></p>
						<ul>
							<li>
								CommonJS (used by Node.js)
								<pre><code class="javascript hljs" data-trim>const $ = require('jquery')</code></pre>
							</li>
							<li>
								Asynchronous Module Definition (AMD)
								<pre><code class="javascript hljs" data-trim>
									define(['jquery', 'underscore'], function($,_){ 
										
									});
								</code></pre>
							</li>
							<li>
								Universal Module Definition (UMD)<br>
								<em>Pattern combining CommonJS, AMD and using global variables to be sure to be understood by all module systems</em>
							</li>
							<li>the use of global variables and the <span class="monospace">&lt;script></span> to be ordered</li>
						</ul>
					</section>
					<section>
						<h3>Modules</h3>
						<div class="flex-center">
							<div>
								<p>Two keywords: <span class="monospace">import</span> and <span class="monospace">export</span></p>
								<p>A distinction is made between named imports and default imports</p>
								<pre><code class="javascript hljs" data-trim>
									import MonModule from './mon-module.js'
									import { a, b as two } from 'module'
									import React, { Component } from 'react'

									export const a = 42
									export function b(){ ... }
									export default { Component, View }
								</code></pre>
							</div>
							<img height="350" src="./assets/img/Image14.png">
						</div>
					</section>
					<section class="left">
						<h3>Modules</h3>
						<p>Modules have a different execution context to traditional scripts:</p>
						<ul>
							<li>
								strict mode used by default <span class="monospace">("use strict";)</span>
								<ul>
									<li>explicit exceptions on certain silent errors</li>
									<li>new keywords are reserved as variable names</li>
									<li>forbids variables not explicitly declared</li>
								</ul>
							</li>
							<li>no global context (<span class="monospace">this === undefined</span> in the global scope)</li>
						</ul>
						<p>The code must therefore be parsed differently if it is a module:</p>
						<ul>
							<li>On browser: <pre><code>&lt;script type="module" src="index.js"&gt;&lt;/script&gt;</code></pre></li>
							<li>
								On Node.js: use <span class="monospace">.mjs</span> extension instead of <span class="monospace">.js</span>, 
								or have <span class="monospace">{ type: "module" }</span> in package.json
							</li>
						</ul>
					</section>
					<section>
						<h3>Modules</h3>
						<img height="350" src="./assets/img/Image21.png" alt="">
						<p>
							<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/</a>
						</p>
					</section>
					<section>
						<h3>Modules: dynamic import </h3>
						<p>
							When <span class="monospace">import</span> is called as a function, the module is imported asynchronously. <br>
							This is very useful for downloading code on demand and optimising the loading time of your applications.
						</p>
						<img height="250" src="./assets/img/Image18.png">
					</section>
					<section>
						<h3>Modules: what about support?</h3>
						<p><a href="https://caniuse.com/es6-module" target="_blank">Good support</a> (~95%) in 2022: Chrome 61+, Edge 16+, Firefox 60+</p>
						<p>But developers use ESM widely in their codebases that are converted to AMD-like bundles by bundlers like Webpack, Parcel, Rollup, esbuild...</p>
						<img height="200" src="./assets/img/Image19.png">
						<p>Bundlers are tools that precompile your code and reduce the browser's work by producing optimized JS bundles from a set of modules during a build step.</p>
					</section>
					<section>
						<h3>Modules: script nomodule</h3>
						<p>
							Browsers that do not support modules won't load <code>&lt;script type="module"></code>
							<br>but they can load an alternative script with the <code>nomodule</code> attribute.
						</p>
						<img height="125" src="./assets/img/Image20.png">
						<p>
							Bundlers can take advantage of this attribute to produce <b>two bundles</b>:<br>
							 a <span class="green">modern</span> bundle, and a <span class="blue">legacy</span> bundle with more transpiled code.</p>
						<p>The modern bundle will be lighter and more efficient, so that support for older browsers does not degrade performance for the modern browsers used by the majority of users.</p>						
					</section>
					<section class="left">
						<h3>Modules : recommandations</h3>
						<p>Always use ESM modules and avoid other existing module systems</p>
						<p>Using a bundler with the "Modern build" option</p>
						<div class="flex-center">
							<ul>
								<li>Parcel: for simplicity and speed of implementation</li>
								<li>Webpack: for complex web applications with advanced needs</li>
								<li>Rollup: for JS libraries</li>
							</ul>
							<img height="100" src="./assets/img/Image22.png" alt="">
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>Deal with Asynchrony</h2>
						<p>Exercises 12 to 14</p>
					</section>
					<section class="left">
						<h3>What is Asynchronism ?</h3>
						<p>JavaScript is executed in an <b>mono-thread environment</b> (the engine only runs one instruction at a time).</p>
						<p>Some instructions may take some time (I/O, network requests…) and must not block the execution of the rest of the program.</p>
						<p>So we make them <b>asynchronous</b>: they declare a function call to be carried out later, after a defined or undefined period.</p>
						<p>These future function calls are stored in stacks, and the engine decides when to pop the calls.</p>

						<pre><code class="javascript hljs" data-trim>
							setTimeout(function calledAfter5Seconds(){
								console.log("bye !")
							}, 5 * 1000)

							console.log("hello !")
						</code></pre>
					</section>
					<section class="left">
						<h3>Callbacks</h3>
						<p>The most common interface for asynchronous instructions is the <b>callback function</b>.</p>
						<p>It consists of passing as parameter of an asynchronous function another function (the callback) which will be called later.</p>
						<pre><code class="javascript hljs" data-trim>
							let callback = function(result){ console.log(result) }

							setTimeout(callback, 1000);

							element.addEventListener('click', callback);
						</code></pre>
					</section>
					<section class="left">
						<h3>Publisher/Subscriber</h3>
						<span class="ref">Exercise 12</span>
						<p>This asynchronous communication pattern is based on a principle of subscription to a flow of events.</p>
						<p><code>element.addEventListener</code> is an example of pub/sub.</p>
						<br />
						<p>A pub/sub keeps in memory a list of callbacks (the <b>subscribers</b>).</p>
						<p>It is composed of at least two functions: <b>subscription</b> and <b>emission</b></p>
						<p>Example of a pub/sub API:</p>
						<pre><code class="javascript hljs" data-trim>
							const publisher = new PubSub();

							publisher.on("alert", function onAlert(eventData){
								console.log(eventData)
							})

							publisher.emit("alert", "something happened")
						</code></pre>
					</section>
					<section class="left">
						<h3>Drawbacks of callbacks</h3>
						<p>Callbacks show their limits when a series of asynchronous operations must be chained (executed one after the other).</p>
						<div class="center"><img height="250" src="./assets/img/callback-hell.jpg" alt="The callback hell"></div>
						<p>An exception raised by a callback cannot be catched directly from the parent scope, which is why error handling is often handled with a second argument of the callback function or a second callback function dedicated to error handling.</p>
					</section>
					<section>
						<h3>Promises</h3>
						<ul>
						<li>Promises are objects used to facilitate the coordination of asynchronous operations.</li>
						<li>A Promise represents the promise of a return value in the future. The delay is not necessarily predictable, this value can be available almost immediately or never arrive.</li>
						<li>A Promise is always in one of these 3 states:
						<ul>
							<li><b>pending</b>: initial state, waiting</li>
							<li><b>fulfilled</b>: the promise has been resolved, the operation was successful</li>
							<li><b>rejected</b>: the promise was rejected due to an error</li>
						</ul>
						</li>
						</ul>
					</section>
					<section>
						<h3>Callbacks vs Promises</h3>
						<div class="flex-center" style="align-items: stretch; gap: 1em">
							<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
								doSomething(function(result){

									doAnotherThing(result, function(newResult){

										doFinalThing(newResult, function(finalResult){
											console.log("Final result: ", finalResult)
										}, failureCallback)

									}, failureCallback)

								}, failureCallback)
							</code></pre>
							<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
								doSomething()
								.then(function(result){
									return doAnotherThing(result)
								})
								.then(function(newResult){
									return doFinalThing(newResult)
								})
								.then(function(finalResult){
									console.log("Final result", finalResult)
								})
								.catch(failureCallback)
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Creation of a promise</h3>
						<span class="ref">Exercise 13</span>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							// creating a promise from a callback-based API
							const promise = new Promise((resolve, reject) => {
								const callback = (err, result) => err ? reject(err) : resolve(result)
								doSomethingAsynchronous(callback)
							})

							promise.then(result => {
								console.log(`Promise resolved with ${result}`)
							})
							promise.catch(error => {
								console.log(`Promise rejected with ${error}`)
							})
							promise.finally(() => { // ES2018
								console.log(`Called after either resolve or reject of the promise`)
							})
						</code></pre>
					</section>
					<section>
						<h3>Other methods of creation of Promises</h3>
						<ul>
							<li><code>Promise.resolve(val)</code></li>
							<li><code>Promise.reject(err)</code>
							<p>create a promise immediately resolved/rejected with some value</p></li>
							<br/>
							<li><code>Promise.all([ promise1, promise2, promise3 ])</code>
								<p>create a promise resolved when all the promises passed as arguments are resolved</p>
							</li>
							<li>
								<code>Promise.race([ promise1, promise2, promise3 ])</code>
								<p>create a promise resolved when one of the promises passed as arguments is resolved</p>
							</li>
						</ul>
						<div class="center"><img height="200" src="./assets/img/promise-all-race.jpg" alt="Comparison between Promise.race and Promise.all"></div>
					</section>
					<section>
						<h3>Chaining and parallelism</h3>
						<span class="ref">Quiz</span>
						<pre><code class="javascript hljs" data-trim>
							const wait = promisify(setTimeout)

							Promise.race([
								fetch('/api/notifs').then(res => res.json()),
								wait(10000)
							]).then(([notifs]) => {
								if(notifs){ /* do something */ }
							})
						</code></pre>
						<pre class="fragment fade"><code class="javascript hljs" data-trim>
							Promise.all([
								wait(1000),
								Promise.resolve(data),
								wait(2000)
							])
						</code></pre>
						<pre class="fragment fade"><code class="javascript hljs" data-trim>
							Promise.race([
								cache ? Promise.resolve(cache) : Promise.race([]),
								fetch('/api/data').then(res => res.json())
							])
						</code></pre>
					</section>
					<section>
						<h3>Exception management</h3>
						<pre><code class="javascript hljs" data-trim>
							f1()
							.then(f2)
							.catch(error => {
								// handle the exceptions from f1 or f2
							})
							.then(f3)
							.catch(error => {
								// handle the exceptions coming exclusively from f3
							})
						</code></pre>
						<p>
							<code>then()</code> and <code>catch()</code> can be chained in any order. 
							It allows intermediate error handling in a promise chain.
						</p>
						<aside class="note info">
							<u>Recommended:</u> handle the exceptions at the lowest level possible, but always add a 
							<code>catch()</code> at the highest level to handle uncatched exceptions.
						</aside>
					</section>
					<section>
						<h3>async / await (ES2017)</h3>
						<p>Functions prefixed with the <code>async</code> operator can contain instructions prefixed with <code>await</code>.</p>
						<p><code>await</code> pauses the function execution waiting for the following promise to be resolved.</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							async function myFunction() {
								try {
									const result = await myPromise;
									// my Promise is resolved and the the resolved value is assigned to result
								} catch(err) {
									// myPromise is rejected with error "err"
								}

								// this line is reached only after resolve/reject of myPromise
								return 42
							}
						</code></pre>
					</section>
					<section>
						<h3>async / await: pros and cons</h3>
						<p>
							<img src="./assets/img/thumb-up.png" alt="" style="float: left; clear: both; margin: 0 1em 0 0"/>
							Combines the advantage of asynchronism with the convenience of writing and reading synchronous code
						</p>
						<p>
							<img src="./assets/img/thumb-up.png" alt="" style="float: left; clear: both; margin: 0 1em 0 0"/>
							Allows to unify the management of synchronous errors (exceptions) with the cases of rejection of promises
						</p>
						<p>
							<img src="./assets/img/thumb-down.png" alt="" style="float: left; clear: both; margin: 0 1em 0 0"/>
							Does not encourage the developer to parallelize asynchronous operations, which can slow down the application
						</p>
						<aside class="note info">
							Remember this winning combo: <code>await Promise.all([ ...promises ])</code>
						</aside>
					</section>

					<section>
						<h3>Observable</h3>
						<p>A pattern halfway between Promise and Pub/Sub:
							<ul><li>Promise that can be resolved in several stages</li>
							<li>Event emitter with a completion concept</li>
						</ul></p>
						<div class="center">
							<img src="assets/img/observable-en.png" alt="Timeline of an observable" />
						</div>
						<p>A <a href="https://github.com/tc39/proposal-observable" target="_blank">proposal</a> exist to standardize Observables, but it's still Stage 0 and has not been presented to TC39 yet. However, it's easily implementable by yourself like Pub/Sub.</p>
						<p>This is one of the foundations of ReactiveX and reactive programming.</p>
					</section>

					<section>
						<h3>Observable: example of API (from <a href="https://rxjs.dev/guide/observable" target="_blank">RxJS</a>)</h3>
						<span class="ref">Exercise 14</span>
						<pre style="font-size: 65%"><code class="javascript hljs" data-trim>
							const keyboardObservable = new Observable( subscriber => {
								const onKey = event => {
									if(event.key === "Enter") {
										subscriber.complete();
										document.removeEventListener("keyup", onKey)
									}
									else subscriber.next(event.key)
								}

								document.addEventListener("keyup", onKey)
							});

							const keys = [];
							const keyboardSubscription = keyboardObservable.subscribe({
								next(key){
									if (key === "Escape") keyboardSubscription.unsubscribe();
									else keys.push(key)
								},
								complete(){ alert(keys.join("")) }
							});
						</code></pre>
					</section>

					<section class="left">
						<h3>Tasks, microtasks and event loop</h3>
						<p>The <b>event loop</b> is the mechanism that periodically pops the asynchronous calls.</p>
						<p>Between each iteration of the loop, the browser re-renders the page and processes user events (click, scroll, etc.)</p>
						<p>Modern JS engines store asynchronous calls in two stacks:<ul>
							<li><b>tasks</b>, unstacked at the end of each event loop (examples: <code>setTimeout</code>, <code>setInterval</code>, <code>fetch</code>)</li>
							<li><b>microtasks</b>, unstacked at the end of each task (examples: <code>promise.then</code>, <code>process.nextTick</code>)</li>
						</ul></p>
						<img src="assets/img/event-loop.jpg" alt="Schema of the event loop" />
					</section>

					<section class="left">
						<h3>Work with the event loop</h3>
						<p>Sometimes, you need to wait for the event loop:
						<ul>
							<li>to wait for the DOM to be updated before the next instruction</li>
							<li>to not block the thread when doing a heavy calculation</li>
						</ul>
						</p>
						<p>You then need to create a new task for your callback:
							<ul>
								<li><code>setTimeout(callback, delai)</code>
									with zero delay to minimize waiting time
								</li>
								<li>
									<code>requestAnimationFrame(callback)</code>
									let the browser optimize when a callback is called to get a fluid animation (~ 60 frames per second)
								</li>
								<li>
									<code>requestIdleCallback(callback)</code>
									let the browser optimize when to call the callback when the CPU is not heavily loaded <i>(non standard)</i>
								</li>
							</ul>
						</p>
					</section>
					<section>
						<h3>Work with the event loop</h3>
						<span class="ref">Quiz</span>
						<pre><code class="javascript hljs" data-trim>
							setTimeout(() => console.log(1), 0)
							Promise.resolve().then(() => console.log(2))
							requestAnimationFrame(() => console.log(3))
							requestIdleCallback(() => console.log(4))
							console.log(5)
						</code></pre>

						<p>In what order are the logs displayed ?</p>
						<p class="center" style="font-weight: bold; font-size: 200%;">
						<span class="fragment fade">5 - </span>
						<span class="fragment fade">2 - </span>
						<span class="fragment fade has-brace-bottom">1 - 4 - 3
							<span class="brace"></span>
							<span class="brace-description">variable depending on the CPU activity, but it's the most likely order</span>
						</span>
						</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Object-oriented Programming</h2>
						<p>Exercises 15 to 19</p>
					</section>
					<section class="left">
						<h3>General principles of Object Oriented Programming</h3>
						<ul>
							<li>Represent a problem with elements that can be associated with material objects or concepts</li>
							<li>Bring more proximity between code logic and business logic</li>
							<li>Manipulate objects that contain their own internal state and their own logic</li>
						</ul>
						<br />
						<p><span style="font-style: italic; text-decoration: underline;">Objectives:</span>
						<ul>
							<li>have a more intuitive, self-describing code</li>
							<li>facilitate work in parallel</li>
							<li>facilitate the transition from specification to code</li>
						</ul></p>
					</section>
					<section class="left">
						<h3>Objects and Prototypes</h3>
						<ul>
							<li>Any object has an internal private property called the <b>prototype</b></li>
							<li>Any object can be the prototype of one or many other objects</li>
							<li>You can retrieve the prototype of an object with:<br/>
							<code>Object.getPrototypeOf(obj)</code></li>
							<li>You can reassign dynamically the prototype of an object with:<br/>
							<code>Object.setPrototypeOf(obj, newProto)</code></li>
						</ul>
						<div class="note warning" style="display: block; margin-left: auto; margin-right: 0; width: 500px">
							Do not reassign the prototype in performance-critical parts of your application because it is tricky to optimize for classical JavaScript engines
						</div>
					</section>
					<section class="left">
						<h3>Why "prototype" ?</h3>
						<ul>
							<li>In industry, a <b>prototype</b> is a <b>real physical object</b>, on which mass-produced objects will be based.</li>
							<li>On the same analogy, a <b>class</b> would be more like a <b>plan or diagram to follow</b>, of a more abstract nature and which cannot be manipulated like an object.</li>
							<li>A prototype is taken as an example to create the produced objects, while a produced object can be taken as an example for the implementation of a class.</li>
						</ul>
						<p>The choice of this term serves to illustrate these differences.</p>
					</section>
					<section class="left">
						<h3>Delegation to prototype</h3>
						<p>If for <code><span class="blue">object</span>.<span class="green">prop</span></code>, the property <span class="green">prop</span> is not found in <span class="blue">object</span>, then it
						is searched for in the <b>prototype</b> of <span class="blue">object</span>, then in the <b>prototype</b> of the <b>prototype</b> of <span class="blue">object</span>, and so on...</p>
						<p>This is called <b>prototype delegation</b>, and objects have a <b>prototype chain</b>.</p>
						<p>The "root" prototype is <code>Object.prototype</code>. Its own prototype is <code>null</code>.</p>

						<pre><code class="javascript hljs" data-trim>
							Object.getPrototypeOf([1,2,3]) === Array.prototype
							▸ true
							Object.getPrototypeOf(Array.prototype) === Object.prototype
							▸ true
							Object.getPrototypeOf(Object.prototype)
							▸ null
						</code></pre>
					</section>
					<section class="left">
						<h3>Methods related to the prototype</h3>
						<span class="ref">Exercise 15</span>
						<div class="has-brace-right" style="margin-right: 300px">
							<pre><code class="javascript hljs" data-trim>
								Object.getPrototypeOf(obj)
								Object.setPrototypeOf(obj, newProto)

								let obj = Object.create(proto)

								Object.getOwnPropertyNames(obj)
								Object.getOwnPropertySymbols(obj)
								Object.getOwnPropertyDescriptors(obj)
							</code></pre>
							<div class="brace"></div>
							<div class="brace-description">Methods of the <code>Object</code> constructor</div>
						</div>
						<div class="has-brace-right" style="margin-right: 300px">
							<pre class="has-brace-right"><code class="javascript hljs" data-trim>
								obj.hasOwnProperty("prop")
								obj.isPrototypeOf(anotherObj)
							</code></pre>
							<div class="brace"></div>
							<div class="brace-description">Methods of the prototype <code>Object.prototype</code></div>
						</div>
					</section>
					<section>
						<h3>Beware of misuse of language !</h3>
						<div class="center" style="font-size: 200%; font-weight: bold">classes ≠ prototypes</div>
						<p>There are no classes in JavaScript, but the word is misused to refer to a prototype and its associated constructor.</p>
						<p>Unlike classes, there is no difference in nature between a prototype and an object. A prototype can therefore be manipulated like any other object: assigned by reference, passed as a parameter, exported as a module...</p>
						<img src="assets/img/kinds-of-oop.jpg" height="300" alt="Two kinds of OOP: an analogy with a classroom">
					</section>
					<section>
						<h3>Beware of misuse of language !</h3>
						<div class="center" style="font-size: 200%; font-weight: bold">inheritance ≠ delegation</div>
						<p class="left">An object does not inherit the properties of its prototype, but it <b>delegates</b> them to it: these are not its own properties</p>
						<pre><code class="javascript hljs" data-trim>
							const bob = Object.create({ name: "Anonymous" })
							bob.name = "Bob";

							console.log(bob.name)
							▸ "Bob"

							delete bob.name;
							console.log(bob.name)
							▸ "Anonymous"
						</code></pre>
						<div class="left">
						<p>In the context of OOP with prototypes, delegating can mean:</p>
							<ul>
								<li>retrieve default values</li>
								<li>get a generic implementation of a method</li>
								<li>implement basic behaviors (toString, cast to primitive, etc.)</li>
							</ul>
						</div>
					</section>
					<section class="left">
						<h3 class="center">Beware of misuse of language !</h3>
						<div class="center" style="font-size: 200%; font-weight: bold">interface, override, instance...</div>
						<p>Most of the class-based OOP vocabulary needs to be avoided:</p>
						<ul>
							<li>The prototype is neither an <i>interface</i> nor a <i>contract</i> to fulfill for the object, but an API base on which to rely.</li>
							<li>We do not <i>override</i> properties, but we delegate those that are missing</li>
							<li>The word "instance" makes sense for an instance of a class because it can mean "example". With prototypes, the roles are reversed since it is the prototype that fits better the role of example.</li>
						</ul>
						<div class="note">
							Despite these differences in definition, this vocabulary is still often used (including within the language itself) in order to remain familiar to those accustomed to Java and class-based OOP.<br/>
							It is quite the same historical aberration that brought us the name <i>"Java"</i>Script.
						</div>
					</section>
					<section>
						<h3>Constructors and operator <code class="blue">new</code></h3>
						<p>In JavaScript, a function can be called <i>as a constructor</i> with the operator <code class="blue">new</code></p>
						<pre><code class="javascript hljs" data-trim>
							function Constructor(){
								// init an object
							}

							Constructor() // called as regular function
							new Constructor() // called as constructor
						</code></pre>
						<div class="note info">It's very unlikely you intend to use a function both as a constructor and as a regular function. By convention, those who are intended as constructors have their name starting with an Uppercase letter.</div>
						<div class="note">Arrow functions cannot be invoked as constructors</div>
					</section>
					<section class="left">
						<h3>Prototypes and constructors</h3>
						<p>When <code>new Constructor()</code> is invoked, a new object is created with <code>Constructor.prototype</code> as prototype.</p>
						<p>This is equivalent to call <code>Object.create(Constructor.prototype)</code></p>
						<p>The same principle applies on all native constructors in the language:</p>
						<pre><code class="javascript hljs" data-trim>
							let today = new Date();
							today.getMonth === Date.prototype.getMonth

							let obj = {} // or new Object()
							obj.toString === Object.prototype.toString

							let array = [1,2,3] // or new Array(1,2,3)
							array.concat === Array.prototype.concat
						</code></pre>

						<p>The <code class="blue">instanceof</code> operators determines if an object has been created by the following constructor:</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							x instanceof C ⇔ Object.getPrototypeOf(x) === C.prototype
							[] instanceof Array ⇔ Object.getPrototypeOf([]) === Array.prototype
						</code></pre>
					</section>
					<section>
						<h3>Constructors and context</h3>
						<p>The <code class="blue">new</code> operator changes the way a function is invoked in several ways:</p>
						<pre><code class="javascript hljs" data-trim>
							function hello(){
								console.log(`this === ${this}`)
							}

							let result1 = hello() // this === [object Window]
							let result2 = new hello() // this === [object Object]
						</code></pre>
						<p>The created object is used as execution context of the constructor (<code class="green">this</code>)</p>
						<div class="note">
							<code>new Constructor(…args)</code> <br/>
							≈<br/>
							<code>Constructor.call(Object.create(Constructor.prototype), ...args)</code>
						</div>
						<p>This object is also returned by default by the function, when there is no <code>return</code> instruction.</p>
						<pre><code class="javascript hljs" data-trim>
							console.log(typeof result1) // undefined
							console.log(typeof result2) // object
						</code></pre>
					</section>
					<section class="left">
						<h3>Constructor.prototype</h3>
						<span class="ref">Exercise 16</span>
						<p>Every constructor function has a <code>prototype</code> property that is an object with a <code>constructor</code> property referring to the constructor function.</p>
						<p>That's how you can retrieve the constructor from a constructed object.</p>
						<img src="assets/img/constructor-prototype.jpg" style="float:left; width: 300px; margin-right: 1em" alt="Diagram presenting Constructor and protototype property recursion" />
						<pre><code class="javascript hljs" data-trim>
							function Car() { }

							Car.prototype;
							▸ { constructor: f }

							Car.prototype.constructor === Car
							▸ true
						</code></pre>
						<p>In the prototype, we can declare other properties that will be <b>delegated</b> by the objects created with this constructor:</p>
						<pre><code class="javascript hljs" data-trim>
							Car.prototype.nbWheels = 4;
							const twingo = new Car();
							twingo.nbWheels
							▸ 4
						</code></pre>
					</section>
					<section>
						<h3>Constructor.prototype</h3>
						<div class="note warning" style="width: 500px">Not to be confused: <pre><code class="javascript hljs">Constructor.prototype</code>  ≠  <code class="javascript hljs">Object.getPrototypeOf(Constructor)</code></pre></div>
						<pre class="fragment fade"><code class="javascript hljs js" data-trim>
							function Car(){} ⇔ const Car = new Function()
						</code></pre>
						<pre class="fragment fade"><code class="javascript hljs" data-trim>
							Object.getPrototypeOf(Car) === Function.prototype
						</code></pre>
					</section>
					<section>
						<h3>Constructors flaws</h3>
						<p>Constructors are a commonly used pattern in JS, but they have several flaws:</p>
						<ul>
							<li class="fragment">The prototype constructors are not automatically invoked, you have to do it manually.</li>
							<li class="fragment">The prototype constructor may not have the same signature, which breaks the <a target="_blank" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">principle of substitution</a>.</li>
							<li class="fragment">A <code>constructor</code> property is assigned to created objects, which can break existing code if you use this property for other effects, for example: <code>car.constructor = "Toyota"</code></li>
							<li class="fragment"><code>this</code> keyword does not work the same depending on whether the function is called with operator <code>new</code> or not</li>
							<li class="fragment">It is not possible to declare several constructors</li>
							<li class="fragment">They are confusing for beginners with prototypes</li>
						</ul>
					</section>
					<section>
						<h3>The <code>class</code> operator (ES2015)</h3>
						<p>Syntaxic sugar for declaring a prototype with a constructor</p>
						<div style="position: relative; display: flex;">
							<pre style="font-size: 60%; width: 50%;"><code class="javascript hljs js" data-trim>
								class Person {
									constructor(firstname, lastname) {
										this.firstname = firstname
										this.lastname = lastname
									}

									sayMyName(){
										return `${this.firstname} ${this.lastname}`
									}
								}

								class User extends Person {
									constructor(firstname, lastname, role){
										super(firstname, lastname);
										this.role = role;
									}

									get isAdmin(){
										return this.role === "admin"
									}
								}

								const bill = new User("Bill", "Gates", "admin")
							</code></pre>
							<div class="left">
								<div class="arrow left fragment" style="top: 34px; right: 0px">explicit <code>constructor</code> property</div>
								<div class="arrow left fragment" style="top: 206px; right: -50px;">simplifies the assignation of the prototype</div>
								<div class="arrow left fragment" style="top: 242px; right: -120px">simplifies the call to the prototype constructor</div>
							</div>
						</div>
					</section>
					<section>
						<h3>super</h3>
						<pre><code class="javascript hljs js" data-trim>
							super(...args); // call the prototype constructor

							super.method(); // call a method of the prototype
						</code></pre>
						<p>It is usable without the class operator:</p>
						<pre style="font-size: 60%"><code class="javascript hljs js" data-trim>
							const user = {
								name: "Anonymous",
								getName(){ return this.name }
							}

							const joe = {
								name: "Joe",
								getName(){
									return `joe name: ${this.name} ; user name: ${super.name} : user getName: ${super.getName()}`
								}
							}

							Object.setPrototypeOf(joe, user)

							joe.getName()
							▸ joe name: Joe ; user name: Anonymous ; user getName: Joe
						</code></pre>
					</section>
					<section>
						<h3>static</h3>
						<p>Defines a static property: a property of the constructor itself, not the prototype</p>
						<pre><code class="javascript hljs js" data-trim>
							class C {
								method(){ console.log("method") }

								static methodStatic(){ console.log("static method") }
							}

							(new C()).method() // method in C.prototype
							C.methodStatic() // methodStatic in C
						</code></pre>
						<p>This is basically the same thing than directly assigning the property to the constructor, so not the most useful syntaxic sugar, but it was added for its familiarity for Java developers.</p>
						<pre><code class="javascript hljs js" data-trim>
							C.equivalentStatic = function(){ ... }
						</code></pre>
					</section>
					<section>
						<h3>Constructors flaws, with operator <code>class</code></h3>
						<ul>
							<li class="fragment">The prototype constructors are not automatically invoked, you have to do it manually.
								<div><img alt="fixed" src="assets/img/patch.png" style="height: 28px;" /> still the case but simplified with <code>super()</code></div>
							</li>
							<li class="fragment">The prototype constructor may not have the same signature, which breaks the <a target="_blank" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">principle of substitution</a>.
								<div><img alt="Not fixed" src="assets/img/smiley-sad.png" style="height: 28px;" /> still the case</div></li>
							<li class="fragment">A <code>constructor</code> property is assigned to constructed objects, which can break existing code if you use this property for other effects, for example: <code>car.constructor = "Toyota"</code>
								<div><img alt="fixed" src="assets/img/patch.png" style="height: 28px;" /> still the case but the assignation is explicit to prevent conflicts</div></li>
							<li class="fragment"><code>this</code> keyword does not work the same depending on whether the function is called with operator <code>new</code> or not
								<div><img alt="fixed" src="assets/img/patch.png" style="height: 28px;" /> an exception is raised if constructor is not called with <code>new</code></div></li>
							<li class="fragment">It is not possible to declare several constructors
								<div><img alt="Not fixed" src="assets/img/smiley-sad.png" style="height: 28px;" /> still the case</div></li>
							<li class="fragment">They are confusing for beginners with prototypes
								<div><img alt="Not fixed" src="assets/img/smiley-sad.png" style="height: 28px;" /> adds even more confusion with class-based OOP</div>
							</li>
						</ul>
					</section>
					<section>
						<h3>Alternative to constructors</h3>
						<p>You don't need constructors to make prototype-based OOP. You can rather use:</p>
						<ul class="left">
							<li>Factory functions
								<pre><code class="javascript hljs js" data-trim>
									function createUser({ first, name }){
										const user = Object.create(userProto)
										user.first = first
										user.name = name
										return user
									}
								</code></pre>
							</li>
							<li><code>Object.create</code> and <code>Object.assign</code>
								<pre><code class="javascript hljs js" data-trim>
									const john = Object.assign(Object.create(userProto), {
										first: "John",
										name: "Smith"
									})
								</code></pre>
							</li>
						</ul>
						<p>It fixes all the flaws previously stated, and you don't need these anymore:</p>
						<p><code>new, instanceof, class, super, static</code></p>
					</section>
					<section>
						<h3>class vs Object.create: an example</h3>
						<div class="cols-2">
							<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
								class Foo {
									constructor(who){
										this.me = who
									}
									identify(){
										return `I am ${this.me}`
									}
								}

								class Bar extends Foo {
									speak(){
										return `Hello, ${this.identify()}`
									}
								}

								let b1 = new Bar("b1")
								let b2 = new Bar("b2")

								b1.speak();
								b2.speak();
							</code></pre>
							<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
								const Foo = {
									init(who){
										this.me = who
										return this
									},
									identify(){
										return `I am ${this.me}`
									}
								}

								const Bar = Object.create(Foo)
								Bar.speak = function(){
									return `Hello, ${this.identify()}`
								}

								let b1 = Object.create(Bar).init("b1");
								let b2 = Object.create(Bar).init("b2");

								b1.speak();
								b2.speak();
							</code></pre>
						</div>
					</section>
					<section>
						<h3>Delegation pattern, in short</h3>
						<ul>
							<li>Lighter and simpler model</li>
							<li>Replace the notion of constructors by factory functions or initialization methods </li>
							<li>No longer needs <code>new</code> and <code>instanceof</code> operators</li>
							<li>Requires to get out of the mental model of class hierarchies</li>
						</ul>
						<div class="note left">
							<u>Recommended:</u> <br>
							Use <code>Object.create</code> and <code>class extends</code> with moderation <br>
							Limit the size of your prototype chains as much as possible <br>
							Delegation is a powerful and flexible pattern, but other approachs such as <b>object composition</b> are underused.
						</div>
					</section>

					<section>
						<h3>Object composition (a.k.a. Mixins)</h3>
						<p>Another pattern in JavaScript OOP consists of creating objects by composition.</p>
						<p>This pattern is super simple because JS objects support dynamic assignation of new properties:</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							const mixin = { ...objA, ...objB }
							// or
							const mixin = Object.assign({}, objA, objB)
						</code></pre>
						<p>The composition is ordered, applying arguments from left to right, so that in case of conflicts on one property name, the last one gets priority:</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							let o = { ...{ x: 1 }, ...{ x: 2 }, ...{ x: 3 } }
							o
							▸ { x: 3 }
						</code></pre>
					</section>

					<section>
						<h3>Composition or delegation ?</h3>
						<img src="assets/img/design-patterns-book.png"
						alt="Cover of book: Design Patterns - Elements of Reusable Object-oriented software" style="float: right; height: 200px" />
						<blockquote style="margin: 100px 0 100px auto">
							Favor object composition over class inheritance
							<br>(Gang of Four 1995:20)
						</blockquote>
						<p>In reality, there is no pattern always better than another:<br/>they match with different ways of thinking.</p>
						<p>The flaws of each pattern became clear when you start to excessively use it anywhere.</p>
						<p>Take the time to think about your model,
							do not code by habit.</p>
					</section>

					<section class="left">
						<h3>Exercise: Relations between objects</h3>
						<div class="ref">Exercise 17</div>
						<p>Let's practice on a project example: a web components library</p>
						<p>Objects identified in the model:</p>
						<ul>
							<li><code>Component</code></li>
							<li><code>Clickable</code></li>
							<li><code>Focusable</code></li>
							<li><code>Editable</code></li>
							<li><code>Button</code></li>
							<li><code>Input</code></li>
							<li><code>TextInput</code></li>
						</ul>
						<p>
							<u>Objectives</u>
							<ol>
								<li>think about the model, find the right relations between objects:
									<br><b>Delegation ? Composition ? Encapsulation ?</b>
								</li>
								<li>implement the relations between objects</li>
								<li>test the example using components Button and TextInput</li>
							</ol>
						</p>
					</section>

					<section>
						<h3>Symbol</h3>
						<p>New primitive type since ES2015</p>
						<p>Represents a unique reference:</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							const symbol = Symbol();
							const symbolFoo = Symbol('foo');

							typeof symbol;
							▸ "symbol"

							symbolFoo.toString()
							▸ "Symbol(foo)"

							symbolFoo === Symbol('foo')
							▸ false
						</code></pre>
						<p>Symbols can be used as property keys of an object:</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							const obj = { [symbolFoo]: "bar" };
							Object.getOwnPropertySymbols(obj)
							▸ [Symbol(foo)]
						</code></pre>
					</section>

					<section>
						<h3>Symbols - Global register</h3>
						<p>A global register exists for symbols nevertheless:</p>
						<pre><code class="javascript hljs js" data-trim>
							const symbolFoo = Symbol.for('foo')
							symbolFoo === Symbol.for('foo')
							▸ true
							Symbol.keyFor(symbolFoo)
							▸ "foo"
						</code></pre>
						<div class="note">Use with moderation, otherwise you will lose the primary interest of symbols, namely to be a unique reference</div>
					</section>

					<section>
						<h3>Symbols - Known symbols</h3>
						<p>Some symbols are built-in in ES2015.</p>
						<p>They let you redefine some internal behaviors of the language for an object:</p>
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim>
							const obj = {
								[Symbol.toPrimitive](){ return 42 }
							}

							+obj;
							▸ 42
						</code></pre>
						<p><u>Examples:</u></p>
						<ul>
							<li><code>Symbol.iterator</code>: used when iterating (for loops, spread operator...)</li>
							<li><code>Symbol.hasInstance</code>: used by <code>instanceof</code> operator</li>
							<li><code>Symbol.toPrimitive</code>: used to cast in primitive</li>
							<li><code>Symbol.toStringTag</code>: used by <code>toString</code> method</li>
						</ul>
					</section>

					<section>
						<h3>Iterable objects</h3>
						<p><code>Array</code>, <code>Set</code> and <code>Map</code> are built-in iterable structures that do the job most of the cases.</p>
						<p>But you can also create your own <b>iterable objects</b> for specific needs:<br><i>binary trees, linked lists, graphs...</i></p>
						<p>An object is said <b>iterable</b> when its <code>Symbol.iterator</code> method returns an <b>iterator</b>.</p>
						<p>An <b>iterator</b> is an object with a method <code>next()</code> that returns an object with 2 properties:</p>
						<ul class="narrow">
							<li><code>done</code>: boolean, true if the iteration is finished</li>
							<li><code>value</code>: current value of iteration, undefined if <code>done</code> is true</li>
						</ul>
						<div class="cols-2">
							<pre style="font-size: 60%"><code class="javascript hljs js" data-trim>
								const compteur123 = {
									[Symbol.iterator]: function(){
										let nombres = [1, 2, 3]
										return {
											next(){
												return {
													done: nombres.length === 0,
													value: nombres.shift()
												}
											}
										}
									}
								}
							</code></pre>
							<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
								for(let n of compteur123) console.log(n);
								▸ 1
								▸ 2
								▸ 3

								[...compteur123]
								▸ [1, 2, 3]
							</code></pre>
						</div>
					</section>

					<section>
						<h3>function* and generators</h3>
						<div class="ref">Exercise 18</div>
						<p>A generator is a special type of function used to simplify the creation of iterators. A generator is declared with operator <b>function*</b>, which allow the use of the <code>yield</code> operator inside.</p>
						<pre style="font-size: 60%"><code class="javascript hljs js" data-trim>
							const compteur123 = {
								[Symbol.iterator]: function*(){
									let nombres = [1, 2, 3];
									while(nombres.length) yield nombres.shift();
								}
							}

							[...compteur123]
							▸ [1, 2, 3]
						</code></pre>
						<p><code>yield</code> let you pause the execution of the generator function and returns an intermediate result. The execution will resume on <code>next()</code> call.</p>
						<p>Iteration is finished at the end of function instructions, or when meeting a <code>return</code> instruction.</p>
					</section>

					<section>
						<h3>Proxy</h3>
						<p>Proxies, introduced in ES2015, let you intercept and customize the operations made on objects:</p>
						<ul class="narrow">
							<li>enumerate and describe its properties</li>
							<li>define, assign, or delete some properties</li>
							<li>invoke it as function or constructor</li>
							<li>get or set its prototype</li>
							<li>...</li>
						</ul>
						<p>A <code>Proxy</code> does not change the original object, it returns a new object reference, and all the operations shall be done on this new reference.</p>
						<p>By default, no operation is intercepted nor modified so the proxy object is indistinguishable from the original object.</p>
						<pre style="font-size: 60%"><code class="javascript hljs js" data-trim>
							const obj = { foo: "bar" }
							const proxy = new Proxy(obj, {
								get(obj, prop){
									console.log(`get ${prop} intercepted`)
									return "intercepted!"
								}
							})

							proxy.foo;
							▸ get foo intercepted!

							obj.foo;
							▸ bar
						</code></pre>
					</section>
					<section>
						<h3>Proxy traps</h3>
						<pre><code class="javascript hljs js" data-trim>
							new Proxy(object, {
								get(o, key){}, // read property value
								set(o, key, val){}, // write a new value for property
								deleteProperty(o, key){},
								apply(o, context, args){}, // invoke as function
								construct(o, args){}, // invoke as constructor
								ownKeys(o){}, // enumerate own properties
								has(o, key){}, // query if property exists
								defineProperty(o, key, desc){},
								getOwnPropertyDescriptor(o, key){},
								getPrototypeOf(o){}
								setPrototypeOf(o, proto){}
							})
						</code></pre>
					</section>
					<section>
						<h3>Reflect API</h3>
						<p><b>Reflect</b> represents the capacity for <a href="https://en.wikipedia.org/wiki/Reflective_programming" target="_blank">reflection</a> acquired by JS with the introduction of proxies.</p>
						<p>The <code>Reflect</code> object contains a set of methods that reproduce the default behavior of the language for all the Proxy traps. You can see it as the default value of every <code>Proxy</code> trap.</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							Reflect.get(o, key) ⇔ o[key]
							Reflect.set(o, key, val) ⇔ o[key] = val
							Reflect.has(o, key) ⇔ key in o
							Reflect.apply(o, context, args) ⇔ o.apply(context, args)
							...
						</code></pre>
						<p>You can easily break existing behaviors you didn't even know existed when playing with proxies. A good practice and safety measure is to always call the Reflect API when adding a proxy trap.</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							new Proxy(obj, {
								set(o, key, value){
									if(typeof value !== "string"){
										throw "Only strings are accepted as values for this object"
									} 
									return Reflect.set(o, key, value) // back to the default behavior
								}
							})
						</code></pre>
					</section>
					<section class="left">
						<h3>Use cases for Proxies</h3>
						<div class="ref">Exercise 19</div>
						<ul>
							<li>Defensive objects: prevent object mutations, throw exceptions when trying to read an undefined property...</li>
							<li>Watchers: publisher/subscriber event system on object mutations (<a href="https://vuejs.org/guide/extras/reactivity-in-depth.html#how-reactivity-works-in-vue" target="_blank">Vue.js</a>, <a href="https://mobx.js.org/configuration.html#proxy-support" target="_blank">MobX</a>)</li>
							<li>Strong type-checking: validate types or values assigned to objects (<a href="https://objectmodel.js.org" target="_blank">objectmodel.js.org</a>)</li>
							<li>Hiding private properties</li>
							<li>Function memoization for performance imrpovements</li>
							<li>Debugging, performance measurement</li>
							<li>...</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Functional programming</h2>
						<p>Exercices 20 to 22</p>
					</section>
					<section class="left">
						<h3>General principles of Functional Programming</h3>
						<ul>
							<li>Decompose a problem into <b>atomic</b>, <b>generic</b> and <b>composable</b> functions</li>
							<li>Favor <b>pure functions</b>, i.e. not using non-local variables and having no side effects</li>
							<li>Avoid object <b>mutations</b></li>
						</ul>
						<p><span style="font-style: italic; text-decoration: underline;">Objectives:</span></p>
						<ul>
							<li>have a more predictable code</li>
							<li>reduce developer mental load</li>
							<li>reduce the number of bugs</li>
							<li>eliminate dead code more easily</li>
						</ul>
					</section>
					<section>
						<h3>Function patterns: Recursivity</h3>
						<p>A <b>recursive</b> function invokes itself with other arguments until reaching a <b>stop condition</b>.</p>
						<pre><code class="javascript hljs js" data-trim>
							const factorial = n => n &gt; 2 ? 1 : n * factorial(n-1)

							const flatten = ([x, ...xs]) => x === undefined 
								? []
								: [ ...(Array.isArray(x) ? flatten(x) : x), ...flatten(xs) ]
						</code></pre>
						<div class="note">
							A useful pattern but not the most readable and with the risk of an infinite loop. <br>
							<u>Recommended:</u> use it only for minimalist functions, and explicit the recursivity with code comments
						</div>
					</section>
					<section>
						<h3>Chainable API</h3>
						<div class="ref">Exercise 20</div>
						<p>A <b>chainable</b> method returns its own execution context (<code>return this</code>) or an object of the same type/prototype in order to be able to chain the calls to this method.</p>
						<p><i>Example: <code>Array.prototype</code> chainable methods</i></p>
						<pre><code class="javascript hljs js" data-trim>
							[1, 2, 3, 4]
								.concat(5, 6, 7, 8)
								.map(n => n**2 + 1)
								.filter(isPrime)
								.slice(0, 5)
								.join(", ") + " are prime numbers"
							▸ "2, 5, 17, 37 are prime numbers"
						</code></pre>
						<p>Chainable API are convenient to use because they reduce sequences of instructions to a single expression.
						 They made the success of famous JS libraries like <a href="https://jquery.com/" target="_blank">jQuery</a> or <a href="https://lodash.com/" target="_blank">lodash</a>.</p>
					</section>
					<section>
						<h3>Function composition</h3>
						<div class="ref">Exercise 21</div>
						<p><b>Function composition</b> consists of creating a composed function that sequentially calls several other functions, each with the return value of the previous one:</p>
						<p class="center" style="font-size: 150%"><code>compose(f,g,h)(x) ⇔ h(g(f(x)))</code></p>
						<p>Function composition can be a relevant solution when:</p>
						<ul>
							<li>a function is too long or takes too many parameters</li>
							<li>a variable is only used once for an intermediate calculation</li>
							<li>the developer is tempted to copy-paste some code</li>
						</ul>
						<p>Compared to chainable API, function composition favors independent functions over methods, which avoids overloading objects with too many properties.</p>
					</section>
					<section>
						<h3>Currying</h3>
						<p style="font-style: italic; color: gray">From <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank">Haskell Curry</a>, a mathematician who laid the foundations of functional programming.</p>
						<p><b>Currying</b> means transforming a function that takes N arguments into a function taking the 1st argument only and returning another function taking the 2nd argument only, and so on until having collected the N arguments necessary to compute and return the final result:</p>
						<p class="center" style="font-size: 150%"><code>f(a,b,c) ⇔ curry(f)(a)(b)(c)</code></p>
						<p>Arrow functions make it easy to transform functions into curryied ones:</p>
						<pre><code class="javascript hljs js" data-trim>
							const sum = (a,b,c) => a + b + c
							const sum = a => b => c => a + b + c // curryied version
						</code></pre>
						<br>
						<p>A more flexible definition allows passing any number of arguments at each step:</p>
						<p class="center"><code>curry(f)(a,b)(c) ⇔ curry(f)(a)(b,c) ⇔ curry(f)(a)(b)(c)</code></p>
					</section>
					<section>
						<h3>Currying: use cases</h3>
						<div class="ref">Exercise 22</div>
						<p><b>Currying</b> is used to apply part of the arguments to decline a generic function into a more specialized version of it: this is called <b>partial application</b>.</p>						
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim>
							const sum = a => b => a + b
							const increment = sum(1);

							increment(42)
							▸ 43

							const replace = curry((before, after, str) => str.replace(before, after))
							const replaceSpacesBy = replace(/\s/g);
							const trim = replaceSpacesBy("")

							trim("     Hello !    ")
							▸ "Hello!"
						</code></pre>
						<br>
						<div class="note">
							In practice, we often introduce currying in a codebase the opposite way:<br>
							starting from a function doing some specific work, we rewrite it into a more generic version, 
							then use partial application to get back to the original specific use case.
						</div>
					</section>
					<section>
						<h3>Partial application with <code>fn.bind</code></h3>
						<p>Partial application can also be done with the <code>bind</code> function in <code>Function.prototype</code>:</p>
						<pre><code class="javascript hljs js" data-trim>
							const where = (field, condition, array) => array.filter(
								row => condition(row[field])
							)

							const whereAgeIs = where.bind(null, "age")
							whereAgeIs(n => n > 10, data)

							const whereAgeIsOver18 = where.bind(null, "age", n => n > 18)
							whereAgeIsOver18(data)
						</code></pre>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<p>How to refactor a code to obtain pure, atomic, generic and composable functions ?</p>
						<p>Let's start from this code example:</p>
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim contenteditable="true">
							import data from "users.json"
							let results = [];

							function printUsersOverAge18(){
								data.sort((a,b) => a.lastName &lt; b.lastName ? -1 : 1)
								results = data.filter(user => user.age >= 18).slice(0, 5)

								const output = results.map(user => user.firstName).join("\n")
								document.querySelector("#results").textContent = output
							}
						</code></pre>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<div class="note"><b>Step 1: get rid of non-local variables</b><br>Pass non-local variables as function arguments. If they are reassigned, make them return values.</div>
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim contenteditable="true">
							import data from "users.json"
							let results = [];

							function printUsersOverAge18(){
								data.sort((a,b) => a.lastName &lt; b.lastName ? -1 : 1)
								results = data.filter(user => user.age >= 18).slice(0, 5)

								const output = results.map(user => user.firstName).join("\n")
								document.querySelector("#results").textContent = output
							}
						</code></pre>
						<div class="note info">Reassigning non-local variables is a side-effect that often leads to developer mistakes and bugs.</div>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<div class="note"><b>Step 2: take out the side effects</b><br>Replace mutations with equivalent immutable instructions when possible. Otherwise, try to isolate them.</div>
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim contenteditable="true">
							import data from "users.json"

							function printUsersOverAge18(data){
								data.sort((a,b) => a.lastName &lt; b.lastName ? -1 : 1)
								const results = data.filter(user => user.age >= 18).slice(0, 5)

								const output = results.map(user => user.firstName).join("\n")
								document.querySelector("#results").textContent = output

								return results
							}

							const results = printUsersOverAge18(data)
						</code></pre>
						<div class="note info">1 function = 1 role ; externalizing side effects helps to decompose a code and understand it better.</div>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<div class="note"><b>Step 3: decompose logic in pure, composable functions</b></div>
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim contenteditable="true">
							import data from "users.json"

							function getUsersOverAge18(data){
								const sortedData = [...data].sort((a,b) => a.lastName &lt; b.lastName ? -1 : 1)
								const results = sortedData.filter(user => user.age >= 18).slice(0, 5)

								const output = results.map(user => user.firstName).join("\n")
								return { results, output }
							}

							const { results, output } = getUsersOverAge18(data)
							document.querySelector("#results").textContent = output
						</code></pre>
						<div class="note info">After removing non-local variables and side effects, it is much easier to decompose code into composable functions.</div>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<div class="note"><b>Step 4: make functions generic</b><br>Pass any arbitrary value as parameter. Add arguments mapping functions if necessary.</div>
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim contenteditable="true">
							import data from "users.json"
							import { compose } from "utils/functions.js";

							const sortByLastName = data => [...data].sort(
															(a,b) => a.lastName &lt; b.lastName ? -1 : 1)

							const filterAgeOver18 = data => data.filter(user => user.age >= 18)
							const takeFive = data => data.slice(0, 5)
							const getFirstNames = users => users.map(user => user.firstName)

							const getUsersOverAge18 = compose(sortByLastName, filterAgeOver18, takeFive)

							const results = getUsersOverAge18(data)
							const output = getFirstNames(results).join("\n")

							document.querySelector("#results").textContent = output
						</code></pre>
						<div class="note info">Magic numbers and other undocumented constants encourages copy-pasting code and creates technical debt.</div>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<div class="note"><b>Step 5: currying functions</b> to reduce the number of arguments and remove superfluous mapping functions</div>
						<pre style="font-size: 80%"><code class="javascript hljs js" data-trim contenteditable="true">
							import data from "users.json"
							import { compose } from "utils/functions.js";

							const sortBy = (key, data) => [...data].sort((a,b) => a[key]] &lt; b[key] ? -1 : 1)
							const filterBy = (key, test, data) => data.filter(({ [key]: val }) => test(val))
							const take = (nb, data) => data.slice(0, nb)
							const mapToProp = (key, data) => data.map(({ [key]: val }) => val)

							const getUsersOverAge18 = compose(
								data => sortBy("lastName", data),
								data => filterBy("age", n => n >= 18, data),
								data => take(5, data)
							);

							const results = getUsersOverAge18(data)
							const output = mapToProp("firstName", results).join("\n")
							document.querySelector("#results").textContent = output
						</code></pre>
						<div class="note info">Currying is very efficient to ease the composition of generic functions.</div>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<div class="note"><b>Step 6: reorganize your modules</b> ; check each decomposed function obtained to decide whether it should be in this file or moved somewhere else.</div>
						<pre style="font-size: 75%"><code class="javascript hljs js" data-trim contenteditable="true">
							import data from "users.json"
							import { compose } from "utils/functions.js";

							const sortBy = key => data => [...data].sort((a,b) => a[key]] &lt; b[key] ? -1 : 1)
							const filterBy = key => test => data => data.filter(({ [key]: val }) => test(val))
							const take = nb => data => data.slice(0, nb)
							const mapToProp = key => data => data.map(({ [key]: val }) => val)

							const getUsersOverAge18 = compose(
								sortBy("lastName"),
								filterBy("age", n => n >= 18),
								take(5)
							);

							const results = getUsersOverAge18(data)
							const output = mapToProp("firstName", results).join("\n")
							document.querySelector("#results").textContent = output
						</code></pre>
						<div class="note info">A functional refactoring is useless if code is badly organized or if reusable functions are not reused</div>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>
						<div style="position: relative">
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							/* BEFORE */
							import data from "users.json"
							let results = [];

							function printUsersOverAge18(){
								data.sort((a,b) => a.lastName &lt; b.lastName ? -1 : 1)
								results = data.filter(user => user.age >= 18).slice(0, 5)

								const output = results.map(user => user.firstName).join("\n")
								document.querySelector("#results").textContent = output
							}
						</code></pre>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							/* AFTER */
							import data from "users.json"
							import { compose } from "utils/functions.js";
							import { sortBy, filterBy, take, mapToProp } from "utils/array.js";

							const getUsersOverAge18 = compose(
								sortBy("lastName"),
								filterBy("age", n => n >= 18),
								take(5)
							);

							const results = getUsersOverAge18(data)
							const output = mapToProp("firstName", results).join("\n")
							document.querySelector("#results").textContent = output
						</code></pre>
						<div class="arrow left" style="top: 310px; left: 780px; background: black; padding: 0.5em; font-size: 80%; width: 12em; border: 3px solid white;">
							what we get at the end: pure, atomic, generic and composable functions
						</div>
						</div>
					</section>
					<section>
						<h3>Functional refactoring in practice</h3>						
						<p>To refactor a code and obtain pure atomic generic and composable functions:</p>
						<img src="./assets/img/cook.png" style="float: right; width: 200px" />
						<ol>
							<li><i class="grey">Collecting ingredients</i>
								<br>Replace non-local variables with new arguments or return values
							</li>
							<li><i class="grey">Slicing</i>
								<br>Extract and isolate side effects and mutations
							</li>
							<li><i class="grey">Combine ingredients</i>
								<br>Compose into series of pure functions
							</li>
							<li>
								<i class="grey">Boil and simmer</i>
								<br>Extract arbitrary values to make it more generic
							</li>
							<li>
								<i class="grey">Add the spices</i>
								<br>Curry functions to reduce the arguments and simplify code
							</li>
							<li>
								<i class="grey">Set the table</i>
								<br>Reorganize your modules, externalize generic functions
							</li>
						</ol>
						<div class="note">Over time, you will be able to make your own <b>functional toolbox</b>, a recipe book reusable in different projects.</div>
					</section>
				</section>
				<section>
					<section>
						<h2>Beyond JavaScript</h2>
						<p>Transpilers and JavaScript supersets</p>
					</section>
					<section>
						<h3>Babel transpiler</h3>
						<ul>
							<li><b>Transpiler</b> = source-to-source compiler operating on the same language, or two languages with the same level of abstraction</li>
							<li><img src="./assets/img/babel-logo.png" alt="Babel logo" style="float: right; margin: 0 0 1em 1em">
								Babel is the most popular JS transpiler. It was initially called 6to5 because it converted ES6 to ES5 to get broader browser support (Internet Explorer in particular)</li>
							<li style="clear: both">Example of ES2021 → ES5 transpilation:
								<div class="cols-2">
									<pre style="font-size: 90%"><code class="javascript hljs js" data-trim>
										[1, 2, 3].map(n => n ** 2);

										var [a,,b] = [1, 2, 3]
									</code></pre>
									<pre style="font-size: 90%"><code class="javascript hljs js" data-trim>
										[1, 2, 3].map(function(n){
											return Math.pow(n, 2)
										});

										var _ref = [1, 2, 3],
											a = _ref[0],
											b = _ref[2]
									</code></pre>
								</div>
							</li>
							<li>A Babel plugin exists for almost each TC39 proposal, to experiment new proposals</li>
							<li>Presets of Babel plugins exist for each major version of ECMAScript</li>
						</ul>
					</section>
					<section>
						<h3>@babel/preset-env</h3>
						<ul>
							<li>Since <a href="https://blogs.windows.com/windowsexperience/2022/06/15/internet-explorer-11-has-retired-and-is-officially-out-of-support-what-you-need-to-know/" target="_blank">Internet Explorer has retired</a> and is no longer supported by Microsoft, we got in the evergreen era of web browsers, which make most of Babel transformations no longer required.</li>
							<li>A new Babel preset has been created to reduce the amount of Babel transformations to just what you need based on the <a href="https://browserslist.dev/" target="_blank">list of browsers you want to support</a>.</li>							
						</ul>

						<p><i>package.json:</i>
							<pre><code class="json hljs" data-trim>
								"browserslist": "> 1%; not dead"
							</code></pre>
						</p>
						<p style="text-decoration: underline;">Examples of browserslist queries:</p>
						<ul>
							<li><code>ie 6-8, Firefox >= 30, last 5 Chrome versions</code></li>
							<li><code>cover 95% in US, cover 99% in my stats</code></li>
							<li><code>extends browserslist-config-worldline</code></li>
							<li><code>defaults</code> : <span style="color: gray"> 0.5%, last 2 versions, Firefox ESR, not dead</span></li>
						</ul>
					</section>
					<section>
						<h3>To transpile or not to transpile ?</h3>
						<p class="clear left" style="display: flex;align-items: center">
							<img src="./assets/img/thumb-up.png" alt="Pro" style="margin-right: 1em">
							Transpilation allows the developer to not think about the majority of browser support issues. It is no longer needed to remember which JS feature comes from which version and is supported in which browser.
						</p>
						<p class="clear left" style="display: flex;align-items: center">
							<img src="./assets/img/thumb-down.png" alt="Con" style="margin-right: 1em">
							Transpilation introduces a compilation step, many new dependencies, some risk factors, and a loss of proximity between the code the developer writes and the code that is actually run in production.
						</p>
						<div class="note">
							<p style="text-decoration: underline; font-weight: bold;">Recommended:</p>
							<ul class="narrow">
								<li>Transpile to a minimum in development mode</li>
								<li>Use preset-env to reduce the amount of transpilation</li>
								<li>Integrate transpilation with other existing build processes (linters, bundlers, minification...)</li>
								<li>Use source maps with your debugging tools</li>
							</ul>
							<p>Fortunately, most of the frameworks build tooling is preconfigured like that !</p>
						</div>
					</section>
					<section>
						<h3>TypeScript</h3>
						<ul>
							<li>
								<img src="./assets/img/ts-logo.png" alt="TypeScript logo" style="float: right;margin: 0 0 1em 1em">
								TypeScript is a superset of JavaScript developed by Microsoft and published in 2012</li>
							<li>It has an official transpiler, <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank">tsc</a>, but many other alternative transpilers exist: <a href="https://esbuild.github.io/" target="_blank">esbuild</a>, <a href="https://bun.sh/" target="_blank">bun</a>, even a Babel preset.</li>
							<li>The key-feature of TypeScript is the <b>static optional typing annotations</b></li>
							<li>Other cool features: interfaces, decorators, enums, abstract classes</li>
							<li>Gradually adoptable: with type definitions (<code>*.d.ts</code> files), TypeScript can catch mistakes even without any TS-specific syntax.</li>
							<li>Try it online on this <a href="https://www.typescriptlang.org/play" target="_blank">playground</a></li>
						</ul>
						<div class="note">
							In 10 years, TypeScript popularity has continuously grown. In 2022, it it a major part of the front-end ecosystem.<br/>
							It is supported in all major web frameworks and improves both the developer experience and the code reliability, especially for medium-to-large apps.
						</div>
					</section>
					<section>
						<h3>JSX</h3>
						<ul>
							<li>
								<img src="./assets/img/jsx-logo.png" alt="JSX logo" style="float: right;height: 125px;margin: 0 0 1em 1em">
								<span>JSX is another superset of JavaScript developed by Facebook, originally for the framework <b>React</b></span>
							</li>
							<li>JSX is now supported by other frameworks than React, such as Vue.js or Preact</li>
							<li>JSX is an abstraction for <b>manipulating virtual DOM elements</b>, which is usually done with templates and a custom templating syntax in other frameworks.</li>
						</ul>
						<img src="./assets/img/jsx-example.png" alt="JSX example code">
						<div class="note">
							JSX's popularity is stagnant and the language is still debated in the JS community, especially because of HTML vs. JS keyword conflicts ; for example, the "class" HTML attribute in JSX must be rewritten "className" to avoid clashing with the <code>class</code> operator in JavaScript.
						</div>
					</section>
				</section>
				<section class="agenda">
					<h2>Retrospective</h2>
					<div class="flex-slide">
						<div style="flex-basis: 100%;">
							<p class="chapter-title">Introduction</p>
							<ul>
								<li>ECMAScript, TC39 and versions of JavaScript</li>
							</ul>
							<p class="chapter-title">A reintroduction to JavaScript</p>
							<ul>
								<li>Primitives and Objects</li>
								<li>Property descriptors</li>
								<li>Scopes and Closures</li>
								<li>Functions and contexts</li>
								<li>Implicit casts</li>
							</ul>
						</div>
						<div style="flex-basis: 100%;">
							<p class="chapter-title">Modern JS: ES2015+</p>
							<ul>
								<li>Arrow functions</li>
								<li>Default parameters</li>
								<li>Spread / Rest</li>
								<li>Destructuring</li>
								<li>Template literals</li>
								<li>Map and Sets</li>
								<li>Modules</li>
							</ul>
	
							<p class="chapter-title">Managing asynchronicity</p>
							<ul>
								<li>Asynchronicity, what is it?</li>
								<li>Callbacks and Pub/Sub</li>
								<li>Promises</li>
								<li>async / await</li>
								<li>Observables</li>
							</ul>
						</div>

						<div style="flex-basis: 100%;">
							<p class="chapter-title">Object oriented</p>
							<ul>
								<li>Prototypes and delegation</li>
								<li>class / super / extends</li>
								<li>Composition of objects</li>
								<li>Symbols, iterables and generators</li>
								<li>Proxies</li>
							</ul>
	
							<p class="chapter-title">Functional programming</p>
							<ul>
								<li>Recursivity</li>
								<li>Chainable APIs</li>
								<li>Function Composition</li>
								<li>Currying</li>
							</ul>

							<p class="chapter-title">Transpilers</p>
							<ul>
								<li>Babel</li>
								<li>TypeScript, JSX</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<a href="./"><img src="./assets/img/JavaScript-logo.png" alt="logo" class="logo"></a>
					<h1 data-i18n="title">JavaScript Training</h1>
					<p>End of training, congratulations !</p>
				</section>
			</div>
		</div>
	</body>

	<script src="./assets/plugin/notes/notes.js"></script>
	<script src="./assets/plugin/highlight/highlight.js"></script>
	<script src="./assets/plugin/internation/internation.js"></script>
	<script type="module" src="./main.js"></script>
</html>